{
    "False": "Help on bool object:\n\nclass bool(int)\n |  bool(x) -> bool\n |  \n |  Returns True when the argument x is true, False otherwise.\n |  The builtins True and False are the only two instances of the class bool.\n |  The class bool is a subclass of the class int, and cannot be subclassed.\n |  \n |  Method resolution order:\n |      bool\n |      int\n |      object\n |  \n |  Methods defined here:\n |  \n |  __and__(self, value, /)\n |      Return self&value.\n |  \n |  __or__(self, value, /)\n |      Return self|value.\n |  \n |  __rand__(self, value, /)\n |      Return value&self.\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __ror__(self, value, /)\n |      Return value|self.\n |  \n |  __rxor__(self, value, /)\n |      Return value^self.\n |  \n |  __xor__(self, value, /)\n |      Return self^value.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from int:\n |  \n |  __abs__(self, /)\n |      abs(self)\n |  \n |  __add__(self, value, /)\n |      Return self+value.\n |  \n |  __bool__(self, /)\n |      self != 0\n |  \n |  __ceil__(...)\n |      Ceiling of an Integral returns itself.\n |  \n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __float__(self, /)\n |      float(self)\n |  \n |  __floor__(...)\n |      Flooring an Integral returns itself.\n |  \n |  __floordiv__(self, value, /)\n |      Return self//value.\n |  \n |  __format__(self, format_spec, /)\n |      Default object formatter.\n |  \n |  __ge__(self, value, /)\n |      Return self>=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getnewargs__(self, /)\n |  \n |  __gt__(self, value, /)\n |      Return self>value.\n |  \n |  __hash__(self, /)\n |      Return hash(self).\n |  \n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |  \n |  __int__(self, /)\n |      int(self)\n |  \n |  __invert__(self, /)\n |      ~self\n |  \n |  __le__(self, value, /)\n |      Return self<=value.\n |  \n |  __lshift__(self, value, /)\n |      Return self<<value.\n |  \n |  __lt__(self, value, /)\n |      Return self<value.\n |  \n |  __mod__(self, value, /)\n |      Return self%value.\n |  \n |  __mul__(self, value, /)\n |      Return self*value.\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __neg__(self, /)\n |      -self\n |  \n |  __pos__(self, /)\n |      +self\n |  \n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |  \n |  __radd__(self, value, /)\n |      Return value+self.\n |  \n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |  \n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |  \n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |  \n |  __rmod__(self, value, /)\n |      Return value%self.\n |  \n |  __rmul__(self, value, /)\n |      Return value*self.\n |  \n |  __round__(...)\n |      Rounding an Integral returns itself.\n |      Rounding with an ndigits argument also returns an integer.\n |  \n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |  \n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |  \n |  __rshift__(self, value, /)\n |      Return self>>value.\n |  \n |  __rsub__(self, value, /)\n |      Return value-self.\n |  \n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |  \n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |  \n |  __sub__(self, value, /)\n |      Return self-value.\n |  \n |  __truediv__(self, value, /)\n |      Return self/value.\n |  \n |  __trunc__(...)\n |      Truncating an Integral returns itself.\n |  \n |  as_integer_ratio(self, /)\n |      Return integer ratio.\n |      \n |      Return a pair of integers, whose ratio is exactly equal to the original int\n |      and with a positive denominator.\n |      \n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |  \n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |      \n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |  \n |  conjugate(...)\n |      Returns self, the complex conjugate of any int.\n |  \n |  to_bytes(self, /, length, byteorder, *, signed=False)\n |      Return an array of bytes representing an integer.\n |      \n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods inherited from int:\n |  \n |  from_bytes(bytes, byteorder, *, signed=False) from builtins.type\n |      Return the integer represented by the given array of bytes.\n |      \n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from int:\n |  \n |  denominator\n |      the denominator of a rational number in lowest terms\n |  \n |  imag\n |      the imaginary part of a complex number\n |  \n |  numerator\n |      the numerator of a rational number in lowest terms\n |  \n |  real\n |      the real part of a complex number\n\n",
    "None": "Help on NoneType object:\n\nclass NoneType(object)\n |  Methods defined here:\n |  \n |  __bool__(self, /)\n |      self != 0\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n\n",
    "True": "Help on bool object:\n\nclass bool(int)\n |  bool(x) -> bool\n |  \n |  Returns True when the argument x is true, False otherwise.\n |  The builtins True and False are the only two instances of the class bool.\n |  The class bool is a subclass of the class int, and cannot be subclassed.\n |  \n |  Method resolution order:\n |      bool\n |      int\n |      object\n |  \n |  Methods defined here:\n |  \n |  __and__(self, value, /)\n |      Return self&value.\n |  \n |  __or__(self, value, /)\n |      Return self|value.\n |  \n |  __rand__(self, value, /)\n |      Return value&self.\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __ror__(self, value, /)\n |      Return value|self.\n |  \n |  __rxor__(self, value, /)\n |      Return value^self.\n |  \n |  __xor__(self, value, /)\n |      Return self^value.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from int:\n |  \n |  __abs__(self, /)\n |      abs(self)\n |  \n |  __add__(self, value, /)\n |      Return self+value.\n |  \n |  __bool__(self, /)\n |      self != 0\n |  \n |  __ceil__(...)\n |      Ceiling of an Integral returns itself.\n |  \n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __float__(self, /)\n |      float(self)\n |  \n |  __floor__(...)\n |      Flooring an Integral returns itself.\n |  \n |  __floordiv__(self, value, /)\n |      Return self//value.\n |  \n |  __format__(self, format_spec, /)\n |      Default object formatter.\n |  \n |  __ge__(self, value, /)\n |      Return self>=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getnewargs__(self, /)\n |  \n |  __gt__(self, value, /)\n |      Return self>value.\n |  \n |  __hash__(self, /)\n |      Return hash(self).\n |  \n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |  \n |  __int__(self, /)\n |      int(self)\n |  \n |  __invert__(self, /)\n |      ~self\n |  \n |  __le__(self, value, /)\n |      Return self<=value.\n |  \n |  __lshift__(self, value, /)\n |      Return self<<value.\n |  \n |  __lt__(self, value, /)\n |      Return self<value.\n |  \n |  __mod__(self, value, /)\n |      Return self%value.\n |  \n |  __mul__(self, value, /)\n |      Return self*value.\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __neg__(self, /)\n |      -self\n |  \n |  __pos__(self, /)\n |      +self\n |  \n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |  \n |  __radd__(self, value, /)\n |      Return value+self.\n |  \n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |  \n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |  \n |  __rlshift__(self, value, /)\n |      Return value<<self.\n |  \n |  __rmod__(self, value, /)\n |      Return value%self.\n |  \n |  __rmul__(self, value, /)\n |      Return value*self.\n |  \n |  __round__(...)\n |      Rounding an Integral returns itself.\n |      Rounding with an ndigits argument also returns an integer.\n |  \n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |  \n |  __rrshift__(self, value, /)\n |      Return value>>self.\n |  \n |  __rshift__(self, value, /)\n |      Return self>>value.\n |  \n |  __rsub__(self, value, /)\n |      Return value-self.\n |  \n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |  \n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |  \n |  __sub__(self, value, /)\n |      Return self-value.\n |  \n |  __truediv__(self, value, /)\n |      Return self/value.\n |  \n |  __trunc__(...)\n |      Truncating an Integral returns itself.\n |  \n |  as_integer_ratio(self, /)\n |      Return integer ratio.\n |      \n |      Return a pair of integers, whose ratio is exactly equal to the original int\n |      and with a positive denominator.\n |      \n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |  \n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |      \n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |  \n |  conjugate(...)\n |      Returns self, the complex conjugate of any int.\n |  \n |  to_bytes(self, /, length, byteorder, *, signed=False)\n |      Return an array of bytes representing an integer.\n |      \n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods inherited from int:\n |  \n |  from_bytes(bytes, byteorder, *, signed=False) from builtins.type\n |      Return the integer represented by the given array of bytes.\n |      \n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from int:\n |  \n |  denominator\n |      the denominator of a rational number in lowest terms\n |  \n |  imag\n |      the imaginary part of a complex number\n |  \n |  numerator\n |      the numerator of a rational number in lowest terms\n |  \n |  real\n |      the real part of a complex number\n\n",
    "__peg_parser__": "no documentation found for '__peg_parser__'\n\n",
    "and": "Boolean operations\n******************\n\n   or_test  ::= and_test | or_test \"or\" and_test\n   and_test ::= not_test | and_test \"and\" not_test\n   not_test ::= comparison | \"not\" not_test\n\nIn the context of Boolean operations, and also when expressions are\nused by control flow statements, the following values are interpreted\nas false: \"False\", \"None\", numeric zero of all types, and empty\nstrings and containers (including strings, tuples, lists,\ndictionaries, sets and frozensets).  All other values are interpreted\nas true.  User-defined objects can customize their truth value by\nproviding a \"__bool__()\" method.\n\nThe operator \"not\" yields \"True\" if its argument is false, \"False\"\notherwise.\n\nThe expression \"x and y\" first evaluates *x*; if *x* is false, its\nvalue is returned; otherwise, *y* is evaluated and the resulting value\nis returned.\n\nThe expression \"x or y\" first evaluates *x*; if *x* is true, its value\nis returned; otherwise, *y* is evaluated and the resulting value is\nreturned.\n\nNote that neither \"and\" nor \"or\" restrict the value and type they\nreturn to \"False\" and \"True\", but rather return the last evaluated\nargument.  This is sometimes useful, e.g., if \"s\" is a string that\nshould be replaced by a default value if it is empty, the expression\n\"s or 'foo'\" yields the desired value.  Because \"not\" has to create a\nnew value, it returns a boolean value regardless of the type of its\nargument (for example, \"not 'foo'\" produces \"False\" rather than \"''\".)\n\nRelated help topics: EXPRESSIONS, TRUTHVALUE\n\n",
    "as": "The \"with\" statement\n********************\n\nThe \"with\" statement is used to wrap the execution of a block with\nmethods defined by a context manager (see section With Statement\nContext Managers). This allows common \"try\"\u2026\"except\"\u2026\"finally\" usage\npatterns to be encapsulated for convenient reuse.\n\n   with_stmt ::= \"with\" with_item (\",\" with_item)* \":\" suite\n   with_item ::= expression [\"as\" target]\n\nThe execution of the \"with\" statement with one \u201citem\u201d proceeds as\nfollows:\n\n1. The context expression (the expression given in the \"with_item\") is\n   evaluated to obtain a context manager.\n\n2. The context manager\u2019s \"__enter__()\" is loaded for later use.\n\n3. The context manager\u2019s \"__exit__()\" is loaded for later use.\n\n4. The context manager\u2019s \"__enter__()\" method is invoked.\n\n5. If a target was included in the \"with\" statement, the return value\n   from \"__enter__()\" is assigned to it.\n\n   Note:\n\n     The \"with\" statement guarantees that if the \"__enter__()\" method\n     returns without an error, then \"__exit__()\" will always be\n     called. Thus, if an error occurs during the assignment to the\n     target list, it will be treated the same as an error occurring\n     within the suite would be. See step 6 below.\n\n6. The suite is executed.\n\n7. The context manager\u2019s \"__exit__()\" method is invoked.  If an\n   exception caused the suite to be exited, its type, value, and\n   traceback are passed as arguments to \"__exit__()\". Otherwise, three\n   \"None\" arguments are supplied.\n\n   If the suite was exited due to an exception, and the return value\n   from the \"__exit__()\" method was false, the exception is reraised.\n   If the return value was true, the exception is suppressed, and\n   execution continues with the statement following the \"with\"\n   statement.\n\n   If the suite was exited for any reason other than an exception, the\n   return value from \"__exit__()\" is ignored, and execution proceeds\n   at the normal location for the kind of exit that was taken.\n\nThe following code:\n\n   with EXPRESSION as TARGET:\n       SUITE\n\nis semantically equivalent to:\n\n   manager = (EXPRESSION)\n   enter = type(manager).__enter__\n   exit = type(manager).__exit__\n   value = enter(manager)\n   hit_except = False\n\n   try:\n       TARGET = value\n       SUITE\n   except:\n       hit_except = True\n       if not exit(manager, *sys.exc_info()):\n           raise\n   finally:\n       if not hit_except:\n           exit(manager, None, None, None)\n\nWith more than one item, the context managers are processed as if\nmultiple \"with\" statements were nested:\n\n   with A() as a, B() as b:\n       SUITE\n\nis semantically equivalent to:\n\n   with A() as a:\n       with B() as b:\n           SUITE\n\nChanged in version 3.1: Support for multiple context expressions.\n\nSee also:\n\n  **PEP 343** - The \u201cwith\u201d statement\n     The specification, background, and examples for the Python \"with\"\n     statement.\n\nRelated help topics: CONTEXTMANAGERS, EXCEPTIONS, yield\n\n",
    "assert": "The \"assert\" statement\n**********************\n\nAssert statements are a convenient way to insert debugging assertions\ninto a program:\n\n   assert_stmt ::= \"assert\" expression [\",\" expression]\n\nThe simple form, \"assert expression\", is equivalent to\n\n   if __debug__:\n       if not expression: raise AssertionError\n\nThe extended form, \"assert expression1, expression2\", is equivalent to\n\n   if __debug__:\n       if not expression1: raise AssertionError(expression2)\n\nThese equivalences assume that \"__debug__\" and \"AssertionError\" refer\nto the built-in variables with those names.  In the current\nimplementation, the built-in variable \"__debug__\" is \"True\" under\nnormal circumstances, \"False\" when optimization is requested (command\nline option \"-O\").  The current code generator emits no code for an\nassert statement when optimization is requested at compile time.  Note\nthat it is unnecessary to include the source code for the expression\nthat failed in the error message; it will be displayed as part of the\nstack trace.\n\nAssignments to \"__debug__\" are illegal.  The value for the built-in\nvariable is determined when the interpreter starts.\n\n",
    "async": "Coroutines\n**********\n\nNew in version 3.5.\n\n\nCoroutine function definition\n=============================\n\n   async_funcdef ::= [decorators] \"async\" \"def\" funcname \"(\" [parameter_list] \")\"\n                     [\"->\" expression] \":\" suite\n\nExecution of Python coroutines can be suspended and resumed at many\npoints (see *coroutine*).  Inside the body of a coroutine function,\n\"await\" and \"async\" identifiers become reserved keywords; \"await\"\nexpressions, \"async for\" and \"async with\" can only be used in\ncoroutine function bodies.\n\nFunctions defined with \"async def\" syntax are always coroutine\nfunctions, even if they do not contain \"await\" or \"async\" keywords.\n\nIt is a \"SyntaxError\" to use a \"yield from\" expression inside the body\nof a coroutine function.\n\nAn example of a coroutine function:\n\n   async def func(param1, param2):\n       do_stuff()\n       await some_coroutine()\n\n\nThe \"async for\" statement\n=========================\n\n   async_for_stmt ::= \"async\" for_stmt\n\nAn *asynchronous iterable* provides an \"__aiter__\" method that\ndirectly returns an *asynchronous iterator*, which can call\nasynchronous code in its \"__anext__\" method.\n\nThe \"async for\" statement allows convenient iteration over\nasynchronous iterables.\n\nThe following code:\n\n   async for TARGET in ITER:\n       SUITE\n   else:\n       SUITE2\n\nIs semantically equivalent to:\n\n   iter = (ITER)\n   iter = type(iter).__aiter__(iter)\n   running = True\n\n   while running:\n       try:\n           TARGET = await type(iter).__anext__(iter)\n       except StopAsyncIteration:\n           running = False\n       else:\n           SUITE\n   else:\n       SUITE2\n\nSee also \"__aiter__()\" and \"__anext__()\" for details.\n\nIt is a \"SyntaxError\" to use an \"async for\" statement outside the body\nof a coroutine function.\n\n\nThe \"async with\" statement\n==========================\n\n   async_with_stmt ::= \"async\" with_stmt\n\nAn *asynchronous context manager* is a *context manager* that is able\nto suspend execution in its *enter* and *exit* methods.\n\nThe following code:\n\n   async with EXPRESSION as TARGET:\n       SUITE\n\nis semantically equivalent to:\n\n   manager = (EXPRESSION)\n   aenter = type(manager).__aenter__\n   aexit = type(manager).__aexit__\n   value = await aenter(manager)\n   hit_except = False\n\n   try:\n       TARGET = value\n       SUITE\n   except:\n       hit_except = True\n       if not await aexit(manager, *sys.exc_info()):\n           raise\n   finally:\n       if not hit_except:\n           await aexit(manager, None, None, None)\n\nSee also \"__aenter__()\" and \"__aexit__()\" for details.\n\nIt is a \"SyntaxError\" to use an \"async with\" statement outside the\nbody of a coroutine function.\n\nSee also:\n\n  **PEP 492** - Coroutines with async and await syntax\n     The proposal that made coroutines a proper standalone concept in\n     Python, and added supporting syntax.\n\n-[ Footnotes ]-\n\n[1] The exception is propagated to the invocation stack unless there\n    is a \"finally\" clause which happens to raise another exception.\n    That new exception causes the old one to be lost.\n\n[2] A string literal appearing as the first statement in the function\n    body is transformed into the function\u2019s \"__doc__\" attribute and\n    therefore the function\u2019s *docstring*.\n\n[3] A string literal appearing as the first statement in the class\n    body is transformed into the namespace\u2019s \"__doc__\" item and\n    therefore the class\u2019s *docstring*.\n\n",
    "await": "Await expression\n****************\n\nSuspend the execution of *coroutine* on an *awaitable* object. Can\nonly be used inside a *coroutine function*.\n\n   await_expr ::= \"await\" primary\n\nNew in version 3.5.\n\n",
    "break": "The \"break\" statement\n*********************\n\n   break_stmt ::= \"break\"\n\n\"break\" may only occur syntactically nested in a \"for\" or \"while\"\nloop, but not nested in a function or class definition within that\nloop.\n\nIt terminates the nearest enclosing loop, skipping the optional \"else\"\nclause if the loop has one.\n\nIf a \"for\" loop is terminated by \"break\", the loop control target\nkeeps its current value.\n\nWhen \"break\" passes control out of a \"try\" statement with a \"finally\"\nclause, that \"finally\" clause is executed before really leaving the\nloop.\n\nRelated help topics: while, for\n\n",
    "class": "Class definitions\n*****************\n\nA class definition defines a class object (see section The standard\ntype hierarchy):\n\n   classdef    ::= [decorators] \"class\" classname [inheritance] \":\" suite\n   inheritance ::= \"(\" [argument_list] \")\"\n   classname   ::= identifier\n\nA class definition is an executable statement.  The inheritance list\nusually gives a list of base classes (see Metaclasses for more\nadvanced uses), so each item in the list should evaluate to a class\nobject which allows subclassing.  Classes without an inheritance list\ninherit, by default, from the base class \"object\"; hence,\n\n   class Foo:\n       pass\n\nis equivalent to\n\n   class Foo(object):\n       pass\n\nThe class\u2019s suite is then executed in a new execution frame (see\nNaming and binding), using a newly created local namespace and the\noriginal global namespace. (Usually, the suite contains mostly\nfunction definitions.)  When the class\u2019s suite finishes execution, its\nexecution frame is discarded but its local namespace is saved. [3] A\nclass object is then created using the inheritance list for the base\nclasses and the saved local namespace for the attribute dictionary.\nThe class name is bound to this class object in the original local\nnamespace.\n\nThe order in which attributes are defined in the class body is\npreserved in the new class\u2019s \"__dict__\".  Note that this is reliable\nonly right after the class is created and only for classes that were\ndefined using the definition syntax.\n\nClass creation can be customized heavily using metaclasses.\n\nClasses can also be decorated: just like when decorating functions,\n\n   @f1(arg)\n   @f2\n   class Foo: pass\n\nis roughly equivalent to\n\n   class Foo: pass\n   Foo = f1(arg)(f2(Foo))\n\nThe evaluation rules for the decorator expressions are the same as for\nfunction decorators.  The result is then bound to the class name.\n\nChanged in version 3.9: Classes may be decorated with any valid\n\"assignment_expression\". Previously, the grammar was much more\nrestrictive; see **PEP 614** for details.\n\n**Programmer\u2019s note:** Variables defined in the class definition are\nclass attributes; they are shared by instances.  Instance attributes\ncan be set in a method with \"self.name = value\".  Both class and\ninstance attributes are accessible through the notation \u201c\"self.name\"\u201d,\nand an instance attribute hides a class attribute with the same name\nwhen accessed in this way.  Class attributes can be used as defaults\nfor instance attributes, but using mutable values there can lead to\nunexpected results.  Descriptors can be used to create instance\nvariables with different implementation details.\n\nSee also:\n\n  **PEP 3115** - Metaclasses in Python 3000\n     The proposal that changed the declaration of metaclasses to the\n     current syntax, and the semantics for how classes with\n     metaclasses are constructed.\n\n  **PEP 3129** - Class Decorators\n     The proposal that added class decorators.  Function and method\n     decorators were introduced in **PEP 318**.\n\nRelated help topics: CLASSES, SPECIALMETHODS\n\n",
    "continue": "The \"continue\" statement\n************************\n\n   continue_stmt ::= \"continue\"\n\n\"continue\" may only occur syntactically nested in a \"for\" or \"while\"\nloop, but not nested in a function or class definition within that\nloop.  It continues with the next cycle of the nearest enclosing loop.\n\nWhen \"continue\" passes control out of a \"try\" statement with a\n\"finally\" clause, that \"finally\" clause is executed before really\nstarting the next loop cycle.\n\nRelated help topics: while, for\n\n",
    "def": "Function definitions\n********************\n\nA function definition defines a user-defined function object (see\nsection The standard type hierarchy):\n\n   funcdef                   ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\"\n               [\"->\" expression] \":\" suite\n   decorators                ::= decorator+\n   decorator                 ::= \"@\" assignment_expression NEWLINE\n   dotted_name               ::= identifier (\".\" identifier)*\n   parameter_list            ::= defparameter (\",\" defparameter)* \",\" \"/\" [\",\" [parameter_list_no_posonly]]\n                        | parameter_list_no_posonly\n   parameter_list_no_posonly ::= defparameter (\",\" defparameter)* [\",\" [parameter_list_starargs]]\n                                 | parameter_list_starargs\n   parameter_list_starargs   ::= \"*\" [parameter] (\",\" defparameter)* [\",\" [\"**\" parameter [\",\"]]]\n                               | \"**\" parameter [\",\"]\n   parameter                 ::= identifier [\":\" expression]\n   defparameter              ::= parameter [\"=\" expression]\n   funcname                  ::= identifier\n\nA function definition is an executable statement.  Its execution binds\nthe function name in the current local namespace to a function object\n(a wrapper around the executable code for the function).  This\nfunction object contains a reference to the current global namespace\nas the global namespace to be used when the function is called.\n\nThe function definition does not execute the function body; this gets\nexecuted only when the function is called. [2]\n\nA function definition may be wrapped by one or more *decorator*\nexpressions. Decorator expressions are evaluated when the function is\ndefined, in the scope that contains the function definition.  The\nresult must be a callable, which is invoked with the function object\nas the only argument. The returned value is bound to the function name\ninstead of the function object.  Multiple decorators are applied in\nnested fashion. For example, the following code\n\n   @f1(arg)\n   @f2\n   def func(): pass\n\nis roughly equivalent to\n\n   def func(): pass\n   func = f1(arg)(f2(func))\n\nexcept that the original function is not temporarily bound to the name\n\"func\".\n\nChanged in version 3.9: Functions may be decorated with any valid\n\"assignment_expression\". Previously, the grammar was much more\nrestrictive; see **PEP 614** for details.\n\nWhen one or more *parameters* have the form *parameter* \"=\"\n*expression*, the function is said to have \u201cdefault parameter values.\u201d\nFor a parameter with a default value, the corresponding *argument* may\nbe omitted from a call, in which case the parameter\u2019s default value is\nsubstituted.  If a parameter has a default value, all following\nparameters up until the \u201c\"*\"\u201d must also have a default value \u2014 this is\na syntactic restriction that is not expressed by the grammar.\n\n**Default parameter values are evaluated from left to right when the\nfunction definition is executed.** This means that the expression is\nevaluated once, when the function is defined, and that the same \u201cpre-\ncomputed\u201d value is used for each call.  This is especially important\nto understand when a default parameter is a mutable object, such as a\nlist or a dictionary: if the function modifies the object (e.g. by\nappending an item to a list), the default value is in effect modified.\nThis is generally not what was intended.  A way around this is to use\n\"None\" as the default, and explicitly test for it in the body of the\nfunction, e.g.:\n\n   def whats_on_the_telly(penguin=None):\n       if penguin is None:\n           penguin = []\n       penguin.append(\"property of the zoo\")\n       return penguin\n\nFunction call semantics are described in more detail in section Calls.\nA function call always assigns values to all parameters mentioned in\nthe parameter list, either from position arguments, from keyword\narguments, or from default values.  If the form \u201c\"*identifier\"\u201d is\npresent, it is initialized to a tuple receiving any excess positional\nparameters, defaulting to the empty tuple. If the form\n\u201c\"**identifier\"\u201d is present, it is initialized to a new ordered\nmapping receiving any excess keyword arguments, defaulting to a new\nempty mapping of the same type.  Parameters after \u201c\"*\"\u201d or\n\u201c\"*identifier\"\u201d are keyword-only parameters and may only be passed\nused keyword arguments.\n\nParameters may have an *annotation* of the form \u201c\": expression\"\u201d\nfollowing the parameter name.  Any parameter may have an annotation,\neven those of the form \"*identifier\" or \"**identifier\".  Functions may\nhave \u201creturn\u201d annotation of the form \u201c\"-> expression\"\u201d after the\nparameter list.  These annotations can be any valid Python expression.\nThe presence of annotations does not change the semantics of a\nfunction.  The annotation values are available as values of a\ndictionary keyed by the parameters\u2019 names in the \"__annotations__\"\nattribute of the function object.  If the \"annotations\" import from\n\"__future__\" is used, annotations are preserved as strings at runtime\nwhich enables postponed evaluation.  Otherwise, they are evaluated\nwhen the function definition is executed.  In this case annotations\nmay be evaluated in a different order than they appear in the source\ncode.\n\nIt is also possible to create anonymous functions (functions not bound\nto a name), for immediate use in expressions.  This uses lambda\nexpressions, described in section Lambdas.  Note that the lambda\nexpression is merely a shorthand for a simplified function definition;\na function defined in a \u201c\"def\"\u201d statement can be passed around or\nassigned to another name just like a function defined by a lambda\nexpression.  The \u201c\"def\"\u201d form is actually more powerful since it\nallows the execution of multiple statements and annotations.\n\n**Programmer\u2019s note:** Functions are first-class objects.  A \u201c\"def\"\u201d\nstatement executed inside a function definition defines a local\nfunction that can be returned or passed around.  Free variables used\nin the nested function can access the local variables of the function\ncontaining the def.  See section Naming and binding for details.\n\nSee also:\n\n  **PEP 3107** - Function Annotations\n     The original specification for function annotations.\n\n  **PEP 484** - Type Hints\n     Definition of a standard meaning for annotations: type hints.\n\n  **PEP 526** - Syntax for Variable Annotations\n     Ability to type hint variable declarations, including class\n     variables and instance variables\n\n  **PEP 563** - Postponed Evaluation of Annotations\n     Support for forward references within annotations by preserving\n     annotations in a string form at runtime instead of eager\n     evaluation.\n\n",
    "del": "The \"del\" statement\n*******************\n\n   del_stmt ::= \"del\" target_list\n\nDeletion is recursively defined very similar to the way assignment is\ndefined. Rather than spelling it out in full details, here are some\nhints.\n\nDeletion of a target list recursively deletes each target, from left\nto right.\n\nDeletion of a name removes the binding of that name from the local or\nglobal namespace, depending on whether the name occurs in a \"global\"\nstatement in the same code block.  If the name is unbound, a\n\"NameError\" exception will be raised.\n\nDeletion of attribute references, subscriptions and slicings is passed\nto the primary object involved; deletion of a slicing is in general\nequivalent to assignment of an empty slice of the right type (but even\nthis is determined by the sliced object).\n\nChanged in version 3.2: Previously it was illegal to delete a name\nfrom the local namespace if it occurs as a free variable in a nested\nblock.\n\nRelated help topics: BASICMETHODS\n\n",
    "elif": "The \"if\" statement\n******************\n\nThe \"if\" statement is used for conditional execution:\n\n   if_stmt ::= \"if\" assignment_expression \":\" suite\n               (\"elif\" assignment_expression \":\" suite)*\n               [\"else\" \":\" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section Boolean operations\nfor the definition of true and false); then that suite is executed\n(and no other part of the \"if\" statement is executed or evaluated).\nIf all expressions are false, the suite of the \"else\" clause, if\npresent, is executed.\n\nRelated help topics: TRUTHVALUE\n\n",
    "else": "The \"if\" statement\n******************\n\nThe \"if\" statement is used for conditional execution:\n\n   if_stmt ::= \"if\" assignment_expression \":\" suite\n               (\"elif\" assignment_expression \":\" suite)*\n               [\"else\" \":\" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section Boolean operations\nfor the definition of true and false); then that suite is executed\n(and no other part of the \"if\" statement is executed or evaluated).\nIf all expressions are false, the suite of the \"else\" clause, if\npresent, is executed.\n\nRelated help topics: while, for\n\n",
    "except": "The \"try\" statement\n*******************\n\nThe \"try\" statement specifies exception handlers and/or cleanup code\nfor a group of statements:\n\n   try_stmt  ::= try1_stmt | try2_stmt\n   try1_stmt ::= \"try\" \":\" suite\n                 (\"except\" [expression [\"as\" identifier]] \":\" suite)+\n                 [\"else\" \":\" suite]\n                 [\"finally\" \":\" suite]\n   try2_stmt ::= \"try\" \":\" suite\n                 \"finally\" \":\" suite\n\nThe \"except\" clause(s) specify one or more exception handlers. When no\nexception occurs in the \"try\" clause, no exception handler is\nexecuted. When an exception occurs in the \"try\" suite, a search for an\nexception handler is started.  This search inspects the except clauses\nin turn until one is found that matches the exception.  An expression-\nless except clause, if present, must be last; it matches any\nexception.  For an except clause with an expression, that expression\nis evaluated, and the clause matches the exception if the resulting\nobject is \u201ccompatible\u201d with the exception.  An object is compatible\nwith an exception if it is the class or a base class of the exception\nobject, or a tuple containing an item that is the class or a base\nclass of the exception object.\n\nIf no except clause matches the exception, the search for an exception\nhandler continues in the surrounding code and on the invocation stack.\n[1]\n\nIf the evaluation of an expression in the header of an except clause\nraises an exception, the original search for a handler is canceled and\na search starts for the new exception in the surrounding code and on\nthe call stack (it is treated as if the entire \"try\" statement raised\nthe exception).\n\nWhen a matching except clause is found, the exception is assigned to\nthe target specified after the \"as\" keyword in that except clause, if\npresent, and the except clause\u2019s suite is executed.  All except\nclauses must have an executable block.  When the end of this block is\nreached, execution continues normally after the entire try statement.\n(This means that if two nested handlers exist for the same exception,\nand the exception occurs in the try clause of the inner handler, the\nouter handler will not handle the exception.)\n\nWhen an exception has been assigned using \"as target\", it is cleared\nat the end of the except clause.  This is as if\n\n   except E as N:\n       foo\n\nwas translated to\n\n   except E as N:\n       try:\n           foo\n       finally:\n           del N\n\nThis means the exception must be assigned to a different name to be\nable to refer to it after the except clause.  Exceptions are cleared\nbecause with the traceback attached to them, they form a reference\ncycle with the stack frame, keeping all locals in that frame alive\nuntil the next garbage collection occurs.\n\nBefore an except clause\u2019s suite is executed, details about the\nexception are stored in the \"sys\" module and can be accessed via\n\"sys.exc_info()\". \"sys.exc_info()\" returns a 3-tuple consisting of the\nexception class, the exception instance and a traceback object (see\nsection The standard type hierarchy) identifying the point in the\nprogram where the exception occurred.  \"sys.exc_info()\" values are\nrestored to their previous values (before the call) when returning\nfrom a function that handled an exception.\n\nThe optional \"else\" clause is executed if the control flow leaves the\n\"try\" suite, no exception was raised, and no \"return\", \"continue\", or\n\"break\" statement was executed.  Exceptions in the \"else\" clause are\nnot handled by the preceding \"except\" clauses.\n\nIf \"finally\" is present, it specifies a \u2018cleanup\u2019 handler.  The \"try\"\nclause is executed, including any \"except\" and \"else\" clauses.  If an\nexception occurs in any of the clauses and is not handled, the\nexception is temporarily saved. The \"finally\" clause is executed.  If\nthere is a saved exception it is re-raised at the end of the \"finally\"\nclause.  If the \"finally\" clause raises another exception, the saved\nexception is set as the context of the new exception. If the \"finally\"\nclause executes a \"return\", \"break\" or \"continue\" statement, the saved\nexception is discarded:\n\n   >>> def f():\n   ...     try:\n   ...         1/0\n   ...     finally:\n   ...         return 42\n   ...\n   >>> f()\n   42\n\nThe exception information is not available to the program during\nexecution of the \"finally\" clause.\n\nWhen a \"return\", \"break\" or \"continue\" statement is executed in the\n\"try\" suite of a \"try\"\u2026\"finally\" statement, the \"finally\" clause is\nalso executed \u2018on the way out.\u2019\n\nThe return value of a function is determined by the last \"return\"\nstatement executed.  Since the \"finally\" clause always executes, a\n\"return\" statement executed in the \"finally\" clause will always be the\nlast one executed:\n\n   >>> def foo():\n   ...     try:\n   ...         return 'try'\n   ...     finally:\n   ...         return 'finally'\n   ...\n   >>> foo()\n   'finally'\n\nAdditional information on exceptions can be found in section\nExceptions, and information on using the \"raise\" statement to generate\nexceptions may be found in section The raise statement.\n\nChanged in version 3.8: Prior to Python 3.8, a \"continue\" statement\nwas illegal in the \"finally\" clause due to a problem with the\nimplementation.\n\nRelated help topics: EXCEPTIONS\n\n",
    "finally": "The \"try\" statement\n*******************\n\nThe \"try\" statement specifies exception handlers and/or cleanup code\nfor a group of statements:\n\n   try_stmt  ::= try1_stmt | try2_stmt\n   try1_stmt ::= \"try\" \":\" suite\n                 (\"except\" [expression [\"as\" identifier]] \":\" suite)+\n                 [\"else\" \":\" suite]\n                 [\"finally\" \":\" suite]\n   try2_stmt ::= \"try\" \":\" suite\n                 \"finally\" \":\" suite\n\nThe \"except\" clause(s) specify one or more exception handlers. When no\nexception occurs in the \"try\" clause, no exception handler is\nexecuted. When an exception occurs in the \"try\" suite, a search for an\nexception handler is started.  This search inspects the except clauses\nin turn until one is found that matches the exception.  An expression-\nless except clause, if present, must be last; it matches any\nexception.  For an except clause with an expression, that expression\nis evaluated, and the clause matches the exception if the resulting\nobject is \u201ccompatible\u201d with the exception.  An object is compatible\nwith an exception if it is the class or a base class of the exception\nobject, or a tuple containing an item that is the class or a base\nclass of the exception object.\n\nIf no except clause matches the exception, the search for an exception\nhandler continues in the surrounding code and on the invocation stack.\n[1]\n\nIf the evaluation of an expression in the header of an except clause\nraises an exception, the original search for a handler is canceled and\na search starts for the new exception in the surrounding code and on\nthe call stack (it is treated as if the entire \"try\" statement raised\nthe exception).\n\nWhen a matching except clause is found, the exception is assigned to\nthe target specified after the \"as\" keyword in that except clause, if\npresent, and the except clause\u2019s suite is executed.  All except\nclauses must have an executable block.  When the end of this block is\nreached, execution continues normally after the entire try statement.\n(This means that if two nested handlers exist for the same exception,\nand the exception occurs in the try clause of the inner handler, the\nouter handler will not handle the exception.)\n\nWhen an exception has been assigned using \"as target\", it is cleared\nat the end of the except clause.  This is as if\n\n   except E as N:\n       foo\n\nwas translated to\n\n   except E as N:\n       try:\n           foo\n       finally:\n           del N\n\nThis means the exception must be assigned to a different name to be\nable to refer to it after the except clause.  Exceptions are cleared\nbecause with the traceback attached to them, they form a reference\ncycle with the stack frame, keeping all locals in that frame alive\nuntil the next garbage collection occurs.\n\nBefore an except clause\u2019s suite is executed, details about the\nexception are stored in the \"sys\" module and can be accessed via\n\"sys.exc_info()\". \"sys.exc_info()\" returns a 3-tuple consisting of the\nexception class, the exception instance and a traceback object (see\nsection The standard type hierarchy) identifying the point in the\nprogram where the exception occurred.  \"sys.exc_info()\" values are\nrestored to their previous values (before the call) when returning\nfrom a function that handled an exception.\n\nThe optional \"else\" clause is executed if the control flow leaves the\n\"try\" suite, no exception was raised, and no \"return\", \"continue\", or\n\"break\" statement was executed.  Exceptions in the \"else\" clause are\nnot handled by the preceding \"except\" clauses.\n\nIf \"finally\" is present, it specifies a \u2018cleanup\u2019 handler.  The \"try\"\nclause is executed, including any \"except\" and \"else\" clauses.  If an\nexception occurs in any of the clauses and is not handled, the\nexception is temporarily saved. The \"finally\" clause is executed.  If\nthere is a saved exception it is re-raised at the end of the \"finally\"\nclause.  If the \"finally\" clause raises another exception, the saved\nexception is set as the context of the new exception. If the \"finally\"\nclause executes a \"return\", \"break\" or \"continue\" statement, the saved\nexception is discarded:\n\n   >>> def f():\n   ...     try:\n   ...         1/0\n   ...     finally:\n   ...         return 42\n   ...\n   >>> f()\n   42\n\nThe exception information is not available to the program during\nexecution of the \"finally\" clause.\n\nWhen a \"return\", \"break\" or \"continue\" statement is executed in the\n\"try\" suite of a \"try\"\u2026\"finally\" statement, the \"finally\" clause is\nalso executed \u2018on the way out.\u2019\n\nThe return value of a function is determined by the last \"return\"\nstatement executed.  Since the \"finally\" clause always executes, a\n\"return\" statement executed in the \"finally\" clause will always be the\nlast one executed:\n\n   >>> def foo():\n   ...     try:\n   ...         return 'try'\n   ...     finally:\n   ...         return 'finally'\n   ...\n   >>> foo()\n   'finally'\n\nAdditional information on exceptions can be found in section\nExceptions, and information on using the \"raise\" statement to generate\nexceptions may be found in section The raise statement.\n\nChanged in version 3.8: Prior to Python 3.8, a \"continue\" statement\nwas illegal in the \"finally\" clause due to a problem with the\nimplementation.\n\nRelated help topics: EXCEPTIONS\n\n",
    "for": "The \"for\" statement\n*******************\n\nThe \"for\" statement is used to iterate over the elements of a sequence\n(such as a string, tuple or list) or other iterable object:\n\n   for_stmt ::= \"for\" target_list \"in\" expression_list \":\" suite\n                [\"else\" \":\" suite]\n\nThe expression list is evaluated once; it should yield an iterable\nobject.  An iterator is created for the result of the\n\"expression_list\".  The suite is then executed once for each item\nprovided by the iterator, in the order returned by the iterator.  Each\nitem in turn is assigned to the target list using the standard rules\nfor assignments (see Assignment statements), and then the suite is\nexecuted.  When the items are exhausted (which is immediately when the\nsequence is empty or an iterator raises a \"StopIteration\" exception),\nthe suite in the \"else\" clause, if present, is executed, and the loop\nterminates.\n\nA \"break\" statement executed in the first suite terminates the loop\nwithout executing the \"else\" clause\u2019s suite.  A \"continue\" statement\nexecuted in the first suite skips the rest of the suite and continues\nwith the next item, or with the \"else\" clause if there is no next\nitem.\n\nThe for-loop makes assignments to the variables in the target list.\nThis overwrites all previous assignments to those variables including\nthose made in the suite of the for-loop:\n\n   for i in range(10):\n       print(i)\n       i = 5             # this will not affect the for-loop\n                         # because i will be overwritten with the next\n                         # index in the range\n\nNames in the target list are not deleted when the loop is finished,\nbut if the sequence is empty, they will not have been assigned to at\nall by the loop.  Hint: the built-in function \"range()\" returns an\niterator of integers suitable to emulate the effect of Pascal\u2019s \"for i\n:= a to b do\"; e.g., \"list(range(3))\" returns the list \"[0, 1, 2]\".\n\nNote:\n\n  There is a subtlety when the sequence is being modified by the loop\n  (this can only occur for mutable sequences, e.g. lists).  An\n  internal counter is used to keep track of which item is used next,\n  and this is incremented on each iteration.  When this counter has\n  reached the length of the sequence the loop terminates.  This means\n  that if the suite deletes the current (or a previous) item from the\n  sequence, the next item will be skipped (since it gets the index of\n  the current item which has already been treated).  Likewise, if the\n  suite inserts an item in the sequence before the current item, the\n  current item will be treated again the next time through the loop.\n  This can lead to nasty bugs that can be avoided by making a\n  temporary copy using a slice of the whole sequence, e.g.,\n\n     for x in a[:]:\n         if x < 0: a.remove(x)\n\nRelated help topics: break, continue, while\n\n",
    "from": "The \"import\" statement\n**********************\n\n   import_stmt     ::= \"import\" module [\"as\" identifier] (\",\" module [\"as\" identifier])*\n                   | \"from\" relative_module \"import\" identifier [\"as\" identifier]\n                   (\",\" identifier [\"as\" identifier])*\n                   | \"from\" relative_module \"import\" \"(\" identifier [\"as\" identifier]\n                   (\",\" identifier [\"as\" identifier])* [\",\"] \")\"\n                   | \"from\" module \"import\" \"*\"\n   module          ::= (identifier \".\")* identifier\n   relative_module ::= \".\"* module | \".\"+\n\nThe basic import statement (no \"from\" clause) is executed in two\nsteps:\n\n1. find a module, loading and initializing it if necessary\n\n2. define a name or names in the local namespace for the scope where\n   the \"import\" statement occurs.\n\nWhen the statement contains multiple clauses (separated by commas) the\ntwo steps are carried out separately for each clause, just as though\nthe clauses had been separated out into individual import statements.\n\nThe details of the first step, finding and loading modules are\ndescribed in greater detail in the section on the import system, which\nalso describes the various types of packages and modules that can be\nimported, as well as all the hooks that can be used to customize the\nimport system. Note that failures in this step may indicate either\nthat the module could not be located, *or* that an error occurred\nwhile initializing the module, which includes execution of the\nmodule\u2019s code.\n\nIf the requested module is retrieved successfully, it will be made\navailable in the local namespace in one of three ways:\n\n* If the module name is followed by \"as\", then the name following \"as\"\n  is bound directly to the imported module.\n\n* If no other name is specified, and the module being imported is a\n  top level module, the module\u2019s name is bound in the local namespace\n  as a reference to the imported module\n\n* If the module being imported is *not* a top level module, then the\n  name of the top level package that contains the module is bound in\n  the local namespace as a reference to the top level package. The\n  imported module must be accessed using its full qualified name\n  rather than directly\n\nThe \"from\" form uses a slightly more complex process:\n\n1. find the module specified in the \"from\" clause, loading and\n   initializing it if necessary;\n\n2. for each of the identifiers specified in the \"import\" clauses:\n\n   1. check if the imported module has an attribute by that name\n\n   2. if not, attempt to import a submodule with that name and then\n      check the imported module again for that attribute\n\n   3. if the attribute is not found, \"ImportError\" is raised.\n\n   4. otherwise, a reference to that value is stored in the local\n      namespace, using the name in the \"as\" clause if it is present,\n      otherwise using the attribute name\n\nExamples:\n\n   import foo                 # foo imported and bound locally\n   import foo.bar.baz         # foo.bar.baz imported, foo bound locally\n   import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb\n   from foo.bar import baz    # foo.bar.baz imported and bound as baz\n   from foo import attr       # foo imported and foo.attr bound as attr\n\nIf the list of identifiers is replaced by a star (\"'*'\"), all public\nnames defined in the module are bound in the local namespace for the\nscope where the \"import\" statement occurs.\n\nThe *public names* defined by a module are determined by checking the\nmodule\u2019s namespace for a variable named \"__all__\"; if defined, it must\nbe a sequence of strings which are names defined or imported by that\nmodule.  The names given in \"__all__\" are all considered public and\nare required to exist.  If \"__all__\" is not defined, the set of public\nnames includes all names found in the module\u2019s namespace which do not\nbegin with an underscore character (\"'_'\").  \"__all__\" should contain\nthe entire public API. It is intended to avoid accidentally exporting\nitems that are not part of the API (such as library modules which were\nimported and used within the module).\n\nThe wild card form of import \u2014 \"from module import *\" \u2014 is only\nallowed at the module level.  Attempting to use it in class or\nfunction definitions will raise a \"SyntaxError\".\n\nWhen specifying what module to import you do not have to specify the\nabsolute name of the module. When a module or package is contained\nwithin another package it is possible to make a relative import within\nthe same top package without having to mention the package name. By\nusing leading dots in the specified module or package after \"from\" you\ncan specify how high to traverse up the current package hierarchy\nwithout specifying exact names. One leading dot means the current\npackage where the module making the import exists. Two dots means up\none package level. Three dots is up two levels, etc. So if you execute\n\"from . import mod\" from a module in the \"pkg\" package then you will\nend up importing \"pkg.mod\". If you execute \"from ..subpkg2 import mod\"\nfrom within \"pkg.subpkg1\" you will import \"pkg.subpkg2.mod\". The\nspecification for relative imports is contained in the Package\nRelative Imports section.\n\n\"importlib.import_module()\" is provided to support applications that\ndetermine dynamically the modules to be loaded.\n\nRaises an auditing event \"import\" with arguments \"module\", \"filename\",\n\"sys.path\", \"sys.meta_path\", \"sys.path_hooks\".\n\n\nFuture statements\n=================\n\nA *future statement* is a directive to the compiler that a particular\nmodule should be compiled using syntax or semantics that will be\navailable in a specified future release of Python where the feature\nbecomes standard.\n\nThe future statement is intended to ease migration to future versions\nof Python that introduce incompatible changes to the language.  It\nallows use of the new features on a per-module basis before the\nrelease in which the feature becomes standard.\n\n   future_stmt ::= \"from\" \"__future__\" \"import\" feature [\"as\" identifier]\n                   (\",\" feature [\"as\" identifier])*\n                   | \"from\" \"__future__\" \"import\" \"(\" feature [\"as\" identifier]\n                   (\",\" feature [\"as\" identifier])* [\",\"] \")\"\n   feature     ::= identifier\n\nA future statement must appear near the top of the module.  The only\nlines that can appear before a future statement are:\n\n* the module docstring (if any),\n\n* comments,\n\n* blank lines, and\n\n* other future statements.\n\nThe only feature that requires using the future statement is\n\"annotations\" (see **PEP 563**).\n\nAll historical features enabled by the future statement are still\nrecognized by Python 3.  The list includes \"absolute_import\",\n\"division\", \"generators\", \"generator_stop\", \"unicode_literals\",\n\"print_function\", \"nested_scopes\" and \"with_statement\".  They are all\nredundant because they are always enabled, and only kept for backwards\ncompatibility.\n\nA future statement is recognized and treated specially at compile\ntime: Changes to the semantics of core constructs are often\nimplemented by generating different code.  It may even be the case\nthat a new feature introduces new incompatible syntax (such as a new\nreserved word), in which case the compiler may need to parse the\nmodule differently.  Such decisions cannot be pushed off until\nruntime.\n\nFor any given release, the compiler knows which feature names have\nbeen defined, and raises a compile-time error if a future statement\ncontains a feature not known to it.\n\nThe direct runtime semantics are the same as for any import statement:\nthere is a standard module \"__future__\", described later, and it will\nbe imported in the usual way at the time the future statement is\nexecuted.\n\nThe interesting runtime semantics depend on the specific feature\nenabled by the future statement.\n\nNote that there is nothing special about the statement:\n\n   import __future__ [as name]\n\nThat is not a future statement; it\u2019s an ordinary import statement with\nno special semantics or syntax restrictions.\n\nCode compiled by calls to the built-in functions \"exec()\" and\n\"compile()\" that occur in a module \"M\" containing a future statement\nwill, by default, use the new syntax or semantics associated with the\nfuture statement.  This can be controlled by optional arguments to\n\"compile()\" \u2014 see the documentation of that function for details.\n\nA future statement typed at an interactive interpreter prompt will\ntake effect for the rest of the interpreter session.  If an\ninterpreter is started with the \"-i\" option, is passed a script name\nto execute, and the script includes a future statement, it will be in\neffect in the interactive session started after the script is\nexecuted.\n\nSee also:\n\n  **PEP 236** - Back to the __future__\n     The original proposal for the __future__ mechanism.\n\nRelated help topics: MODULES\n\n",
    "global": "The \"global\" statement\n**********************\n\n   global_stmt ::= \"global\" identifier (\",\" identifier)*\n\nThe \"global\" statement is a declaration which holds for the entire\ncurrent code block.  It means that the listed identifiers are to be\ninterpreted as globals.  It would be impossible to assign to a global\nvariable without \"global\", although free variables may refer to\nglobals without being declared global.\n\nNames listed in a \"global\" statement must not be used in the same code\nblock textually preceding that \"global\" statement.\n\nNames listed in a \"global\" statement must not be defined as formal\nparameters or in a \"for\" loop control target, \"class\" definition,\nfunction definition, \"import\" statement, or variable annotation.\n\n**CPython implementation detail:** The current implementation does not\nenforce some of these restrictions, but programs should not abuse this\nfreedom, as future implementations may enforce them or silently change\nthe meaning of the program.\n\n**Programmer\u2019s note:** \"global\" is a directive to the parser.  It\napplies only to code parsed at the same time as the \"global\"\nstatement. In particular, a \"global\" statement contained in a string\nor code object supplied to the built-in \"exec()\" function does not\naffect the code block *containing* the function call, and code\ncontained in such a string is unaffected by \"global\" statements in the\ncode containing the function call.  The same applies to the \"eval()\"\nand \"compile()\" functions.\n\nRelated help topics: nonlocal, NAMESPACES\n\n",
    "if": "The \"if\" statement\n******************\n\nThe \"if\" statement is used for conditional execution:\n\n   if_stmt ::= \"if\" assignment_expression \":\" suite\n               (\"elif\" assignment_expression \":\" suite)*\n               [\"else\" \":\" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section Boolean operations\nfor the definition of true and false); then that suite is executed\n(and no other part of the \"if\" statement is executed or evaluated).\nIf all expressions are false, the suite of the \"else\" clause, if\npresent, is executed.\n\nRelated help topics: TRUTHVALUE\n\n",
    "import": "The \"import\" statement\n**********************\n\n   import_stmt     ::= \"import\" module [\"as\" identifier] (\",\" module [\"as\" identifier])*\n                   | \"from\" relative_module \"import\" identifier [\"as\" identifier]\n                   (\",\" identifier [\"as\" identifier])*\n                   | \"from\" relative_module \"import\" \"(\" identifier [\"as\" identifier]\n                   (\",\" identifier [\"as\" identifier])* [\",\"] \")\"\n                   | \"from\" module \"import\" \"*\"\n   module          ::= (identifier \".\")* identifier\n   relative_module ::= \".\"* module | \".\"+\n\nThe basic import statement (no \"from\" clause) is executed in two\nsteps:\n\n1. find a module, loading and initializing it if necessary\n\n2. define a name or names in the local namespace for the scope where\n   the \"import\" statement occurs.\n\nWhen the statement contains multiple clauses (separated by commas) the\ntwo steps are carried out separately for each clause, just as though\nthe clauses had been separated out into individual import statements.\n\nThe details of the first step, finding and loading modules are\ndescribed in greater detail in the section on the import system, which\nalso describes the various types of packages and modules that can be\nimported, as well as all the hooks that can be used to customize the\nimport system. Note that failures in this step may indicate either\nthat the module could not be located, *or* that an error occurred\nwhile initializing the module, which includes execution of the\nmodule\u2019s code.\n\nIf the requested module is retrieved successfully, it will be made\navailable in the local namespace in one of three ways:\n\n* If the module name is followed by \"as\", then the name following \"as\"\n  is bound directly to the imported module.\n\n* If no other name is specified, and the module being imported is a\n  top level module, the module\u2019s name is bound in the local namespace\n  as a reference to the imported module\n\n* If the module being imported is *not* a top level module, then the\n  name of the top level package that contains the module is bound in\n  the local namespace as a reference to the top level package. The\n  imported module must be accessed using its full qualified name\n  rather than directly\n\nThe \"from\" form uses a slightly more complex process:\n\n1. find the module specified in the \"from\" clause, loading and\n   initializing it if necessary;\n\n2. for each of the identifiers specified in the \"import\" clauses:\n\n   1. check if the imported module has an attribute by that name\n\n   2. if not, attempt to import a submodule with that name and then\n      check the imported module again for that attribute\n\n   3. if the attribute is not found, \"ImportError\" is raised.\n\n   4. otherwise, a reference to that value is stored in the local\n      namespace, using the name in the \"as\" clause if it is present,\n      otherwise using the attribute name\n\nExamples:\n\n   import foo                 # foo imported and bound locally\n   import foo.bar.baz         # foo.bar.baz imported, foo bound locally\n   import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb\n   from foo.bar import baz    # foo.bar.baz imported and bound as baz\n   from foo import attr       # foo imported and foo.attr bound as attr\n\nIf the list of identifiers is replaced by a star (\"'*'\"), all public\nnames defined in the module are bound in the local namespace for the\nscope where the \"import\" statement occurs.\n\nThe *public names* defined by a module are determined by checking the\nmodule\u2019s namespace for a variable named \"__all__\"; if defined, it must\nbe a sequence of strings which are names defined or imported by that\nmodule.  The names given in \"__all__\" are all considered public and\nare required to exist.  If \"__all__\" is not defined, the set of public\nnames includes all names found in the module\u2019s namespace which do not\nbegin with an underscore character (\"'_'\").  \"__all__\" should contain\nthe entire public API. It is intended to avoid accidentally exporting\nitems that are not part of the API (such as library modules which were\nimported and used within the module).\n\nThe wild card form of import \u2014 \"from module import *\" \u2014 is only\nallowed at the module level.  Attempting to use it in class or\nfunction definitions will raise a \"SyntaxError\".\n\nWhen specifying what module to import you do not have to specify the\nabsolute name of the module. When a module or package is contained\nwithin another package it is possible to make a relative import within\nthe same top package without having to mention the package name. By\nusing leading dots in the specified module or package after \"from\" you\ncan specify how high to traverse up the current package hierarchy\nwithout specifying exact names. One leading dot means the current\npackage where the module making the import exists. Two dots means up\none package level. Three dots is up two levels, etc. So if you execute\n\"from . import mod\" from a module in the \"pkg\" package then you will\nend up importing \"pkg.mod\". If you execute \"from ..subpkg2 import mod\"\nfrom within \"pkg.subpkg1\" you will import \"pkg.subpkg2.mod\". The\nspecification for relative imports is contained in the Package\nRelative Imports section.\n\n\"importlib.import_module()\" is provided to support applications that\ndetermine dynamically the modules to be loaded.\n\nRaises an auditing event \"import\" with arguments \"module\", \"filename\",\n\"sys.path\", \"sys.meta_path\", \"sys.path_hooks\".\n\n\nFuture statements\n=================\n\nA *future statement* is a directive to the compiler that a particular\nmodule should be compiled using syntax or semantics that will be\navailable in a specified future release of Python where the feature\nbecomes standard.\n\nThe future statement is intended to ease migration to future versions\nof Python that introduce incompatible changes to the language.  It\nallows use of the new features on a per-module basis before the\nrelease in which the feature becomes standard.\n\n   future_stmt ::= \"from\" \"__future__\" \"import\" feature [\"as\" identifier]\n                   (\",\" feature [\"as\" identifier])*\n                   | \"from\" \"__future__\" \"import\" \"(\" feature [\"as\" identifier]\n                   (\",\" feature [\"as\" identifier])* [\",\"] \")\"\n   feature     ::= identifier\n\nA future statement must appear near the top of the module.  The only\nlines that can appear before a future statement are:\n\n* the module docstring (if any),\n\n* comments,\n\n* blank lines, and\n\n* other future statements.\n\nThe only feature that requires using the future statement is\n\"annotations\" (see **PEP 563**).\n\nAll historical features enabled by the future statement are still\nrecognized by Python 3.  The list includes \"absolute_import\",\n\"division\", \"generators\", \"generator_stop\", \"unicode_literals\",\n\"print_function\", \"nested_scopes\" and \"with_statement\".  They are all\nredundant because they are always enabled, and only kept for backwards\ncompatibility.\n\nA future statement is recognized and treated specially at compile\ntime: Changes to the semantics of core constructs are often\nimplemented by generating different code.  It may even be the case\nthat a new feature introduces new incompatible syntax (such as a new\nreserved word), in which case the compiler may need to parse the\nmodule differently.  Such decisions cannot be pushed off until\nruntime.\n\nFor any given release, the compiler knows which feature names have\nbeen defined, and raises a compile-time error if a future statement\ncontains a feature not known to it.\n\nThe direct runtime semantics are the same as for any import statement:\nthere is a standard module \"__future__\", described later, and it will\nbe imported in the usual way at the time the future statement is\nexecuted.\n\nThe interesting runtime semantics depend on the specific feature\nenabled by the future statement.\n\nNote that there is nothing special about the statement:\n\n   import __future__ [as name]\n\nThat is not a future statement; it\u2019s an ordinary import statement with\nno special semantics or syntax restrictions.\n\nCode compiled by calls to the built-in functions \"exec()\" and\n\"compile()\" that occur in a module \"M\" containing a future statement\nwill, by default, use the new syntax or semantics associated with the\nfuture statement.  This can be controlled by optional arguments to\n\"compile()\" \u2014 see the documentation of that function for details.\n\nA future statement typed at an interactive interpreter prompt will\ntake effect for the rest of the interpreter session.  If an\ninterpreter is started with the \"-i\" option, is passed a script name\nto execute, and the script includes a future statement, it will be in\neffect in the interactive session started after the script is\nexecuted.\n\nSee also:\n\n  **PEP 236** - Back to the __future__\n     The original proposal for the __future__ mechanism.\n\nRelated help topics: MODULES\n\n",
    "in": "Membership test operations\n**************************\n\nThe operators \"in\" and \"not in\" test for membership.  \"x in s\"\nevaluates to \"True\" if *x* is a member of *s*, and \"False\" otherwise.\n\"x not in s\" returns the negation of \"x in s\".  All built-in sequences\nand set types support this as well as dictionary, for which \"in\" tests\nwhether the dictionary has a given key. For container types such as\nlist, tuple, set, frozenset, dict, or collections.deque, the\nexpression \"x in y\" is equivalent to \"any(x is e or x == e for e in\ny)\".\n\nFor the string and bytes types, \"x in y\" is \"True\" if and only if *x*\nis a substring of *y*.  An equivalent test is \"y.find(x) != -1\".\nEmpty strings are always considered to be a substring of any other\nstring, so \"\"\" in \"abc\"\" will return \"True\".\n\nFor user-defined classes which define the \"__contains__()\" method, \"x\nin y\" returns \"True\" if \"y.__contains__(x)\" returns a true value, and\n\"False\" otherwise.\n\nFor user-defined classes which do not define \"__contains__()\" but do\ndefine \"__iter__()\", \"x in y\" is \"True\" if some value \"z\", for which\nthe expression \"x is z or x == z\" is true, is produced while iterating\nover \"y\". If an exception is raised during the iteration, it is as if\n\"in\" raised that exception.\n\nLastly, the old-style iteration protocol is tried: if a class defines\n\"__getitem__()\", \"x in y\" is \"True\" if and only if there is a non-\nnegative integer index *i* such that \"x is y[i] or x == y[i]\", and no\nlower integer index raises the \"IndexError\" exception.  (If any other\nexception is raised, it is as if \"in\" raised that exception).\n\nThe operator \"not in\" is defined to have the inverse truth value of\n\"in\".\n\nRelated help topics: SEQUENCEMETHODS\n\n",
    "is": "Comparisons\n***********\n\nUnlike C, all comparison operations in Python have the same priority,\nwhich is lower than that of any arithmetic, shifting or bitwise\noperation.  Also unlike C, expressions like \"a < b < c\" have the\ninterpretation that is conventional in mathematics:\n\n   comparison    ::= or_expr (comp_operator or_expr)*\n   comp_operator ::= \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\"\n                     | \"is\" [\"not\"] | [\"not\"] \"in\"\n\nComparisons yield boolean values: \"True\" or \"False\".\n\nComparisons can be chained arbitrarily, e.g., \"x < y <= z\" is\nequivalent to \"x < y and y <= z\", except that \"y\" is evaluated only\nonce (but in both cases \"z\" is not evaluated at all when \"x < y\" is\nfound to be false).\n\nFormally, if *a*, *b*, *c*, \u2026, *y*, *z* are expressions and *op1*,\n*op2*, \u2026, *opN* are comparison operators, then \"a op1 b op2 c ... y\nopN z\" is equivalent to \"a op1 b and b op2 c and ... y opN z\", except\nthat each expression is evaluated at most once.\n\nNote that \"a op1 b op2 c\" doesn\u2019t imply any kind of comparison between\n*a* and *c*, so that, e.g., \"x < y > z\" is perfectly legal (though\nperhaps not pretty).\n\n\nValue comparisons\n=================\n\nThe operators \"<\", \">\", \"==\", \">=\", \"<=\", and \"!=\" compare the values\nof two objects.  The objects do not need to have the same type.\n\nChapter Objects, values and types states that objects have a value (in\naddition to type and identity).  The value of an object is a rather\nabstract notion in Python: For example, there is no canonical access\nmethod for an object\u2019s value.  Also, there is no requirement that the\nvalue of an object should be constructed in a particular way, e.g.\ncomprised of all its data attributes. Comparison operators implement a\nparticular notion of what the value of an object is.  One can think of\nthem as defining the value of an object indirectly, by means of their\ncomparison implementation.\n\nBecause all types are (direct or indirect) subtypes of \"object\", they\ninherit the default comparison behavior from \"object\".  Types can\ncustomize their comparison behavior by implementing *rich comparison\nmethods* like \"__lt__()\", described in Basic customization.\n\nThe default behavior for equality comparison (\"==\" and \"!=\") is based\non the identity of the objects.  Hence, equality comparison of\ninstances with the same identity results in equality, and equality\ncomparison of instances with different identities results in\ninequality.  A motivation for this default behavior is the desire that\nall objects should be reflexive (i.e. \"x is y\" implies \"x == y\").\n\nA default order comparison (\"<\", \">\", \"<=\", and \">=\") is not provided;\nan attempt raises \"TypeError\".  A motivation for this default behavior\nis the lack of a similar invariant as for equality.\n\nThe behavior of the default equality comparison, that instances with\ndifferent identities are always unequal, may be in contrast to what\ntypes will need that have a sensible definition of object value and\nvalue-based equality.  Such types will need to customize their\ncomparison behavior, and in fact, a number of built-in types have done\nthat.\n\nThe following list describes the comparison behavior of the most\nimportant built-in types.\n\n* Numbers of built-in numeric types (Numeric Types \u2014 int, float,\n  complex) and of the standard library types \"fractions.Fraction\" and\n  \"decimal.Decimal\" can be compared within and across their types,\n  with the restriction that complex numbers do not support order\n  comparison.  Within the limits of the types involved, they compare\n  mathematically (algorithmically) correct without loss of precision.\n\n  The not-a-number values \"float('NaN')\" and \"decimal.Decimal('NaN')\"\n  are special.  Any ordered comparison of a number to a not-a-number\n  value is false. A counter-intuitive implication is that not-a-number\n  values are not equal to themselves.  For example, if \"x =\n  float('NaN')\", \"3 < x\", \"x < 3\" and \"x == x\" are all false, while \"x\n  != x\" is true.  This behavior is compliant with IEEE 754.\n\n* \"None\" and \"NotImplemented\" are singletons.  **PEP 8** advises that\n  comparisons for singletons should always be done with \"is\" or \"is\n  not\", never the equality operators.\n\n* Binary sequences (instances of \"bytes\" or \"bytearray\") can be\n  compared within and across their types.  They compare\n  lexicographically using the numeric values of their elements.\n\n* Strings (instances of \"str\") compare lexicographically using the\n  numerical Unicode code points (the result of the built-in function\n  \"ord()\") of their characters. [3]\n\n  Strings and binary sequences cannot be directly compared.\n\n* Sequences (instances of \"tuple\", \"list\", or \"range\") can be compared\n  only within each of their types, with the restriction that ranges do\n  not support order comparison.  Equality comparison across these\n  types results in inequality, and ordering comparison across these\n  types raises \"TypeError\".\n\n  Sequences compare lexicographically using comparison of\n  corresponding elements.  The built-in containers typically assume\n  identical objects are equal to themselves.  That lets them bypass\n  equality tests for identical objects to improve performance and to\n  maintain their internal invariants.\n\n  Lexicographical comparison between built-in collections works as\n  follows:\n\n  * For two collections to compare equal, they must be of the same\n    type, have the same length, and each pair of corresponding\n    elements must compare equal (for example, \"[1,2] == (1,2)\" is\n    false because the type is not the same).\n\n  * Collections that support order comparison are ordered the same as\n    their first unequal elements (for example, \"[1,2,x] <= [1,2,y]\"\n    has the same value as \"x <= y\").  If a corresponding element does\n    not exist, the shorter collection is ordered first (for example,\n    \"[1,2] < [1,2,3]\" is true).\n\n* Mappings (instances of \"dict\") compare equal if and only if they\n  have equal *(key, value)* pairs. Equality comparison of the keys and\n  values enforces reflexivity.\n\n  Order comparisons (\"<\", \">\", \"<=\", and \">=\") raise \"TypeError\".\n\n* Sets (instances of \"set\" or \"frozenset\") can be compared within and\n  across their types.\n\n  They define order comparison operators to mean subset and superset\n  tests.  Those relations do not define total orderings (for example,\n  the two sets \"{1,2}\" and \"{2,3}\" are not equal, nor subsets of one\n  another, nor supersets of one another).  Accordingly, sets are not\n  appropriate arguments for functions which depend on total ordering\n  (for example, \"min()\", \"max()\", and \"sorted()\" produce undefined\n  results given a list of sets as inputs).\n\n  Comparison of sets enforces reflexivity of its elements.\n\n* Most other built-in types have no comparison methods implemented, so\n  they inherit the default comparison behavior.\n\nUser-defined classes that customize their comparison behavior should\nfollow some consistency rules, if possible:\n\n* Equality comparison should be reflexive. In other words, identical\n  objects should compare equal:\n\n     \"x is y\" implies \"x == y\"\n\n* Comparison should be symmetric. In other words, the following\n  expressions should have the same result:\n\n     \"x == y\" and \"y == x\"\n\n     \"x != y\" and \"y != x\"\n\n     \"x < y\" and \"y > x\"\n\n     \"x <= y\" and \"y >= x\"\n\n* Comparison should be transitive. The following (non-exhaustive)\n  examples illustrate that:\n\n     \"x > y and y > z\" implies \"x > z\"\n\n     \"x < y and y <= z\" implies \"x < z\"\n\n* Inverse comparison should result in the boolean negation. In other\n  words, the following expressions should have the same result:\n\n     \"x == y\" and \"not x != y\"\n\n     \"x < y\" and \"not x >= y\" (for total ordering)\n\n     \"x > y\" and \"not x <= y\" (for total ordering)\n\n  The last two expressions apply to totally ordered collections (e.g.\n  to sequences, but not to sets or mappings). See also the\n  \"total_ordering()\" decorator.\n\n* The \"hash()\" result should be consistent with equality. Objects that\n  are equal should either have the same hash value, or be marked as\n  unhashable.\n\nPython does not enforce these consistency rules. In fact, the\nnot-a-number values are an example for not following these rules.\n\n\nMembership test operations\n==========================\n\nThe operators \"in\" and \"not in\" test for membership.  \"x in s\"\nevaluates to \"True\" if *x* is a member of *s*, and \"False\" otherwise.\n\"x not in s\" returns the negation of \"x in s\".  All built-in sequences\nand set types support this as well as dictionary, for which \"in\" tests\nwhether the dictionary has a given key. For container types such as\nlist, tuple, set, frozenset, dict, or collections.deque, the\nexpression \"x in y\" is equivalent to \"any(x is e or x == e for e in\ny)\".\n\nFor the string and bytes types, \"x in y\" is \"True\" if and only if *x*\nis a substring of *y*.  An equivalent test is \"y.find(x) != -1\".\nEmpty strings are always considered to be a substring of any other\nstring, so \"\"\" in \"abc\"\" will return \"True\".\n\nFor user-defined classes which define the \"__contains__()\" method, \"x\nin y\" returns \"True\" if \"y.__contains__(x)\" returns a true value, and\n\"False\" otherwise.\n\nFor user-defined classes which do not define \"__contains__()\" but do\ndefine \"__iter__()\", \"x in y\" is \"True\" if some value \"z\", for which\nthe expression \"x is z or x == z\" is true, is produced while iterating\nover \"y\". If an exception is raised during the iteration, it is as if\n\"in\" raised that exception.\n\nLastly, the old-style iteration protocol is tried: if a class defines\n\"__getitem__()\", \"x in y\" is \"True\" if and only if there is a non-\nnegative integer index *i* such that \"x is y[i] or x == y[i]\", and no\nlower integer index raises the \"IndexError\" exception.  (If any other\nexception is raised, it is as if \"in\" raised that exception).\n\nThe operator \"not in\" is defined to have the inverse truth value of\n\"in\".\n\n\nIdentity comparisons\n====================\n\nThe operators \"is\" and \"is not\" test for an object\u2019s identity: \"x is\ny\" is true if and only if *x* and *y* are the same object.  An\nObject\u2019s identity is determined using the \"id()\" function.  \"x is not\ny\" yields the inverse truth value. [4]\n\nRelated help topics: EXPRESSIONS, BASICMETHODS\n\n",
    "lambda": "Lambdas\n*******\n\n   lambda_expr        ::= \"lambda\" [parameter_list] \":\" expression\n   lambda_expr_nocond ::= \"lambda\" [parameter_list] \":\" expression_nocond\n\nLambda expressions (sometimes called lambda forms) are used to create\nanonymous functions. The expression \"lambda parameters: expression\"\nyields a function object.  The unnamed object behaves like a function\nobject defined with:\n\n   def <lambda>(parameters):\n       return expression\n\nSee section Function definitions for the syntax of parameter lists.\nNote that functions created with lambda expressions cannot contain\nstatements or annotations.\n\nRelated help topics: FUNCTIONS\n\n",
    "nonlocal": "The \"nonlocal\" statement\n************************\n\n   nonlocal_stmt ::= \"nonlocal\" identifier (\",\" identifier)*\n\nThe \"nonlocal\" statement causes the listed identifiers to refer to\npreviously bound variables in the nearest enclosing scope excluding\nglobals. This is important because the default behavior for binding is\nto search the local namespace first.  The statement allows\nencapsulated code to rebind variables outside of the local scope\nbesides the global (module) scope.\n\nNames listed in a \"nonlocal\" statement, unlike those listed in a\n\"global\" statement, must refer to pre-existing bindings in an\nenclosing scope (the scope in which a new binding should be created\ncannot be determined unambiguously).\n\nNames listed in a \"nonlocal\" statement must not collide with pre-\nexisting bindings in the local scope.\n\nSee also:\n\n  **PEP 3104** - Access to Names in Outer Scopes\n     The specification for the \"nonlocal\" statement.\n\nRelated help topics: global, NAMESPACES\n\n",
    "not": "Boolean operations\n******************\n\n   or_test  ::= and_test | or_test \"or\" and_test\n   and_test ::= not_test | and_test \"and\" not_test\n   not_test ::= comparison | \"not\" not_test\n\nIn the context of Boolean operations, and also when expressions are\nused by control flow statements, the following values are interpreted\nas false: \"False\", \"None\", numeric zero of all types, and empty\nstrings and containers (including strings, tuples, lists,\ndictionaries, sets and frozensets).  All other values are interpreted\nas true.  User-defined objects can customize their truth value by\nproviding a \"__bool__()\" method.\n\nThe operator \"not\" yields \"True\" if its argument is false, \"False\"\notherwise.\n\nThe expression \"x and y\" first evaluates *x*; if *x* is false, its\nvalue is returned; otherwise, *y* is evaluated and the resulting value\nis returned.\n\nThe expression \"x or y\" first evaluates *x*; if *x* is true, its value\nis returned; otherwise, *y* is evaluated and the resulting value is\nreturned.\n\nNote that neither \"and\" nor \"or\" restrict the value and type they\nreturn to \"False\" and \"True\", but rather return the last evaluated\nargument.  This is sometimes useful, e.g., if \"s\" is a string that\nshould be replaced by a default value if it is empty, the expression\n\"s or 'foo'\" yields the desired value.  Because \"not\" has to create a\nnew value, it returns a boolean value regardless of the type of its\nargument (for example, \"not 'foo'\" produces \"False\" rather than \"''\".)\n\nRelated help topics: EXPRESSIONS, TRUTHVALUE\n\n",
    "or": "Boolean operations\n******************\n\n   or_test  ::= and_test | or_test \"or\" and_test\n   and_test ::= not_test | and_test \"and\" not_test\n   not_test ::= comparison | \"not\" not_test\n\nIn the context of Boolean operations, and also when expressions are\nused by control flow statements, the following values are interpreted\nas false: \"False\", \"None\", numeric zero of all types, and empty\nstrings and containers (including strings, tuples, lists,\ndictionaries, sets and frozensets).  All other values are interpreted\nas true.  User-defined objects can customize their truth value by\nproviding a \"__bool__()\" method.\n\nThe operator \"not\" yields \"True\" if its argument is false, \"False\"\notherwise.\n\nThe expression \"x and y\" first evaluates *x*; if *x* is false, its\nvalue is returned; otherwise, *y* is evaluated and the resulting value\nis returned.\n\nThe expression \"x or y\" first evaluates *x*; if *x* is true, its value\nis returned; otherwise, *y* is evaluated and the resulting value is\nreturned.\n\nNote that neither \"and\" nor \"or\" restrict the value and type they\nreturn to \"False\" and \"True\", but rather return the last evaluated\nargument.  This is sometimes useful, e.g., if \"s\" is a string that\nshould be replaced by a default value if it is empty, the expression\n\"s or 'foo'\" yields the desired value.  Because \"not\" has to create a\nnew value, it returns a boolean value regardless of the type of its\nargument (for example, \"not 'foo'\" produces \"False\" rather than \"''\".)\n\nRelated help topics: EXPRESSIONS, TRUTHVALUE\n\n",
    "pass": "The \"pass\" statement\n********************\n\n   pass_stmt ::= \"pass\"\n\n\"pass\" is a null operation \u2014 when it is executed, nothing happens. It\nis useful as a placeholder when a statement is required syntactically,\nbut no code needs to be executed, for example:\n\n   def f(arg): pass    # a function that does nothing (yet)\n\n   class C: pass       # a class with no methods (yet)\n\n",
    "raise": "The \"raise\" statement\n*********************\n\n   raise_stmt ::= \"raise\" [expression [\"from\" expression]]\n\nIf no expressions are present, \"raise\" re-raises the last exception\nthat was active in the current scope.  If no exception is active in\nthe current scope, a \"RuntimeError\" exception is raised indicating\nthat this is an error.\n\nOtherwise, \"raise\" evaluates the first expression as the exception\nobject.  It must be either a subclass or an instance of\n\"BaseException\". If it is a class, the exception instance will be\nobtained when needed by instantiating the class with no arguments.\n\nThe *type* of the exception is the exception instance\u2019s class, the\n*value* is the instance itself.\n\nA traceback object is normally created automatically when an exception\nis raised and attached to it as the \"__traceback__\" attribute, which\nis writable. You can create an exception and set your own traceback in\none step using the \"with_traceback()\" exception method (which returns\nthe same exception instance, with its traceback set to its argument),\nlike so:\n\n   raise Exception(\"foo occurred\").with_traceback(tracebackobj)\n\nThe \"from\" clause is used for exception chaining: if given, the second\n*expression* must be another exception class or instance, which will\nthen be attached to the raised exception as the \"__cause__\" attribute\n(which is writable).  If the raised exception is not handled, both\nexceptions will be printed:\n\n   >>> try:\n   ...     print(1 / 0)\n   ... except Exception as exc:\n   ...     raise RuntimeError(\"Something bad happened\") from exc\n   ...\n   Traceback (most recent call last):\n     File \"<stdin>\", line 2, in <module>\n   ZeroDivisionError: division by zero\n\n   The above exception was the direct cause of the following exception:\n\n   Traceback (most recent call last):\n     File \"<stdin>\", line 4, in <module>\n   RuntimeError: Something bad happened\n\nA similar mechanism works implicitly if an exception is raised inside\nan exception handler or a \"finally\" clause: the previous exception is\nthen attached as the new exception\u2019s \"__context__\" attribute:\n\n   >>> try:\n   ...     print(1 / 0)\n   ... except:\n   ...     raise RuntimeError(\"Something bad happened\")\n   ...\n   Traceback (most recent call last):\n     File \"<stdin>\", line 2, in <module>\n   ZeroDivisionError: division by zero\n\n   During handling of the above exception, another exception occurred:\n\n   Traceback (most recent call last):\n     File \"<stdin>\", line 4, in <module>\n   RuntimeError: Something bad happened\n\nException chaining can be explicitly suppressed by specifying \"None\"\nin the \"from\" clause:\n\n   >>> try:\n   ...     print(1 / 0)\n   ... except:\n   ...     raise RuntimeError(\"Something bad happened\") from None\n   ...\n   Traceback (most recent call last):\n     File \"<stdin>\", line 4, in <module>\n   RuntimeError: Something bad happened\n\nAdditional information on exceptions can be found in section\nExceptions, and information about handling exceptions is in section\nThe try statement.\n\nChanged in version 3.3: \"None\" is now permitted as \"Y\" in \"raise X\nfrom Y\".\n\nNew in version 3.3: The \"__suppress_context__\" attribute to suppress\nautomatic display of the exception context.\n\nRelated help topics: EXCEPTIONS\n\n",
    "return": "The \"return\" statement\n**********************\n\n   return_stmt ::= \"return\" [expression_list]\n\n\"return\" may only occur syntactically nested in a function definition,\nnot within a nested class definition.\n\nIf an expression list is present, it is evaluated, else \"None\" is\nsubstituted.\n\n\"return\" leaves the current function call with the expression list (or\n\"None\") as return value.\n\nWhen \"return\" passes control out of a \"try\" statement with a \"finally\"\nclause, that \"finally\" clause is executed before really leaving the\nfunction.\n\nIn a generator function, the \"return\" statement indicates that the\ngenerator is done and will cause \"StopIteration\" to be raised. The\nreturned value (if any) is used as an argument to construct\n\"StopIteration\" and becomes the \"StopIteration.value\" attribute.\n\nIn an asynchronous generator function, an empty \"return\" statement\nindicates that the asynchronous generator is done and will cause\n\"StopAsyncIteration\" to be raised.  A non-empty \"return\" statement is\na syntax error in an asynchronous generator function.\n\nRelated help topics: FUNCTIONS\n\n",
    "try": "The \"try\" statement\n*******************\n\nThe \"try\" statement specifies exception handlers and/or cleanup code\nfor a group of statements:\n\n   try_stmt  ::= try1_stmt | try2_stmt\n   try1_stmt ::= \"try\" \":\" suite\n                 (\"except\" [expression [\"as\" identifier]] \":\" suite)+\n                 [\"else\" \":\" suite]\n                 [\"finally\" \":\" suite]\n   try2_stmt ::= \"try\" \":\" suite\n                 \"finally\" \":\" suite\n\nThe \"except\" clause(s) specify one or more exception handlers. When no\nexception occurs in the \"try\" clause, no exception handler is\nexecuted. When an exception occurs in the \"try\" suite, a search for an\nexception handler is started.  This search inspects the except clauses\nin turn until one is found that matches the exception.  An expression-\nless except clause, if present, must be last; it matches any\nexception.  For an except clause with an expression, that expression\nis evaluated, and the clause matches the exception if the resulting\nobject is \u201ccompatible\u201d with the exception.  An object is compatible\nwith an exception if it is the class or a base class of the exception\nobject, or a tuple containing an item that is the class or a base\nclass of the exception object.\n\nIf no except clause matches the exception, the search for an exception\nhandler continues in the surrounding code and on the invocation stack.\n[1]\n\nIf the evaluation of an expression in the header of an except clause\nraises an exception, the original search for a handler is canceled and\na search starts for the new exception in the surrounding code and on\nthe call stack (it is treated as if the entire \"try\" statement raised\nthe exception).\n\nWhen a matching except clause is found, the exception is assigned to\nthe target specified after the \"as\" keyword in that except clause, if\npresent, and the except clause\u2019s suite is executed.  All except\nclauses must have an executable block.  When the end of this block is\nreached, execution continues normally after the entire try statement.\n(This means that if two nested handlers exist for the same exception,\nand the exception occurs in the try clause of the inner handler, the\nouter handler will not handle the exception.)\n\nWhen an exception has been assigned using \"as target\", it is cleared\nat the end of the except clause.  This is as if\n\n   except E as N:\n       foo\n\nwas translated to\n\n   except E as N:\n       try:\n           foo\n       finally:\n           del N\n\nThis means the exception must be assigned to a different name to be\nable to refer to it after the except clause.  Exceptions are cleared\nbecause with the traceback attached to them, they form a reference\ncycle with the stack frame, keeping all locals in that frame alive\nuntil the next garbage collection occurs.\n\nBefore an except clause\u2019s suite is executed, details about the\nexception are stored in the \"sys\" module and can be accessed via\n\"sys.exc_info()\". \"sys.exc_info()\" returns a 3-tuple consisting of the\nexception class, the exception instance and a traceback object (see\nsection The standard type hierarchy) identifying the point in the\nprogram where the exception occurred.  \"sys.exc_info()\" values are\nrestored to their previous values (before the call) when returning\nfrom a function that handled an exception.\n\nThe optional \"else\" clause is executed if the control flow leaves the\n\"try\" suite, no exception was raised, and no \"return\", \"continue\", or\n\"break\" statement was executed.  Exceptions in the \"else\" clause are\nnot handled by the preceding \"except\" clauses.\n\nIf \"finally\" is present, it specifies a \u2018cleanup\u2019 handler.  The \"try\"\nclause is executed, including any \"except\" and \"else\" clauses.  If an\nexception occurs in any of the clauses and is not handled, the\nexception is temporarily saved. The \"finally\" clause is executed.  If\nthere is a saved exception it is re-raised at the end of the \"finally\"\nclause.  If the \"finally\" clause raises another exception, the saved\nexception is set as the context of the new exception. If the \"finally\"\nclause executes a \"return\", \"break\" or \"continue\" statement, the saved\nexception is discarded:\n\n   >>> def f():\n   ...     try:\n   ...         1/0\n   ...     finally:\n   ...         return 42\n   ...\n   >>> f()\n   42\n\nThe exception information is not available to the program during\nexecution of the \"finally\" clause.\n\nWhen a \"return\", \"break\" or \"continue\" statement is executed in the\n\"try\" suite of a \"try\"\u2026\"finally\" statement, the \"finally\" clause is\nalso executed \u2018on the way out.\u2019\n\nThe return value of a function is determined by the last \"return\"\nstatement executed.  Since the \"finally\" clause always executes, a\n\"return\" statement executed in the \"finally\" clause will always be the\nlast one executed:\n\n   >>> def foo():\n   ...     try:\n   ...         return 'try'\n   ...     finally:\n   ...         return 'finally'\n   ...\n   >>> foo()\n   'finally'\n\nAdditional information on exceptions can be found in section\nExceptions, and information on using the \"raise\" statement to generate\nexceptions may be found in section The raise statement.\n\nChanged in version 3.8: Prior to Python 3.8, a \"continue\" statement\nwas illegal in the \"finally\" clause due to a problem with the\nimplementation.\n\nRelated help topics: EXCEPTIONS\n\n",
    "while": "The \"while\" statement\n*********************\n\nThe \"while\" statement is used for repeated execution as long as an\nexpression is true:\n\n   while_stmt ::= \"while\" assignment_expression \":\" suite\n                  [\"else\" \":\" suite]\n\nThis repeatedly tests the expression and, if it is true, executes the\nfirst suite; if the expression is false (which may be the first time\nit is tested) the suite of the \"else\" clause, if present, is executed\nand the loop terminates.\n\nA \"break\" statement executed in the first suite terminates the loop\nwithout executing the \"else\" clause\u2019s suite.  A \"continue\" statement\nexecuted in the first suite skips the rest of the suite and goes back\nto testing the expression.\n\nRelated help topics: break, continue, if, TRUTHVALUE\n\n",
    "with": "The \"with\" statement\n********************\n\nThe \"with\" statement is used to wrap the execution of a block with\nmethods defined by a context manager (see section With Statement\nContext Managers). This allows common \"try\"\u2026\"except\"\u2026\"finally\" usage\npatterns to be encapsulated for convenient reuse.\n\n   with_stmt ::= \"with\" with_item (\",\" with_item)* \":\" suite\n   with_item ::= expression [\"as\" target]\n\nThe execution of the \"with\" statement with one \u201citem\u201d proceeds as\nfollows:\n\n1. The context expression (the expression given in the \"with_item\") is\n   evaluated to obtain a context manager.\n\n2. The context manager\u2019s \"__enter__()\" is loaded for later use.\n\n3. The context manager\u2019s \"__exit__()\" is loaded for later use.\n\n4. The context manager\u2019s \"__enter__()\" method is invoked.\n\n5. If a target was included in the \"with\" statement, the return value\n   from \"__enter__()\" is assigned to it.\n\n   Note:\n\n     The \"with\" statement guarantees that if the \"__enter__()\" method\n     returns without an error, then \"__exit__()\" will always be\n     called. Thus, if an error occurs during the assignment to the\n     target list, it will be treated the same as an error occurring\n     within the suite would be. See step 6 below.\n\n6. The suite is executed.\n\n7. The context manager\u2019s \"__exit__()\" method is invoked.  If an\n   exception caused the suite to be exited, its type, value, and\n   traceback are passed as arguments to \"__exit__()\". Otherwise, three\n   \"None\" arguments are supplied.\n\n   If the suite was exited due to an exception, and the return value\n   from the \"__exit__()\" method was false, the exception is reraised.\n   If the return value was true, the exception is suppressed, and\n   execution continues with the statement following the \"with\"\n   statement.\n\n   If the suite was exited for any reason other than an exception, the\n   return value from \"__exit__()\" is ignored, and execution proceeds\n   at the normal location for the kind of exit that was taken.\n\nThe following code:\n\n   with EXPRESSION as TARGET:\n       SUITE\n\nis semantically equivalent to:\n\n   manager = (EXPRESSION)\n   enter = type(manager).__enter__\n   exit = type(manager).__exit__\n   value = enter(manager)\n   hit_except = False\n\n   try:\n       TARGET = value\n       SUITE\n   except:\n       hit_except = True\n       if not exit(manager, *sys.exc_info()):\n           raise\n   finally:\n       if not hit_except:\n           exit(manager, None, None, None)\n\nWith more than one item, the context managers are processed as if\nmultiple \"with\" statements were nested:\n\n   with A() as a, B() as b:\n       SUITE\n\nis semantically equivalent to:\n\n   with A() as a:\n       with B() as b:\n           SUITE\n\nChanged in version 3.1: Support for multiple context expressions.\n\nSee also:\n\n  **PEP 343** - The \u201cwith\u201d statement\n     The specification, background, and examples for the Python \"with\"\n     statement.\n\nRelated help topics: CONTEXTMANAGERS, EXCEPTIONS, yield\n\n",
    "yield": "The \"yield\" statement\n*********************\n\n   yield_stmt ::= yield_expression\n\nA \"yield\" statement is semantically equivalent to a yield expression.\nThe yield statement can be used to omit the parentheses that would\notherwise be required in the equivalent yield expression statement.\nFor example, the yield statements\n\n   yield <expr>\n   yield from <expr>\n\nare equivalent to the yield expression statements\n\n   (yield <expr>)\n   (yield from <expr>)\n\nYield expressions and statements are only used when defining a\n*generator* function, and are only used in the body of the generator\nfunction.  Using yield in a function definition is sufficient to cause\nthat definition to create a generator function instead of a normal\nfunction.\n\nFor full details of \"yield\" semantics, refer to the Yield expressions\nsection.\n\n"
}